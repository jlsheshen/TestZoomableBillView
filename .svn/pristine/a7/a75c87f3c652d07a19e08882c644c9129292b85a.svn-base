package com.edu.testbill.billview.view;

import java.util.ArrayList;
import java.util.List;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.support.v4.view.GestureDetectorCompat;
import android.util.AttributeSet;
import android.util.Log;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup;
import android.widget.Scroller;
import android.widget.Toast;

import com.edu.testbill.billview.BillTemplate;
import com.edu.testbill.billview.BillZoomListener;
import com.edu.testbill.billview.ElementLayoutParams;
import com.edu.testbill.billview.ElementType;
import com.edu.testbill.billview.data.BaseElementData;
import com.edu.testbill.billview.data.BlankData;
import com.edu.testbill.billview.data.FlashData;
import com.edu.testbill.billview.data.SignData;
import com.edu.zoomcontrol.R;

/**
 * 支持缩放，自由滚动，智能滚动等功能的单据视图
 * 
 * @author lucher
 * 
 */
public class ZoomableBillView extends ViewGroup implements OnLongClickListener {

	private static final String TAG = ZoomableBillView.class.getSimpleName();

	// 支持的最大缩放倍数
	private static final int MAX_SCALE_TIMES = 2;
	// 初始化缩放比例，根据图片和当前控件的实际尺寸计算出，如果图片宽大于实际尺寸，此值将小于0
	private float mInitScale = -1;
	// 当前缩放比例
	private float mScale = mInitScale;
	// 缩放比重
	private float mScaleWeight = 1.2f;
	// 缩放监听
	private BillZoomListener mListener;
	// 当前是否可放大，缩小
	private boolean mZoomInEnable, mZoomOutEnable;
	// 缩放标识，true：放大，false：缩小
	private boolean mZoomFlag;
	// 当前缩放倍数
	private int mCurrentScaleTimes = 0;

	// 字体大小
	private float mTextSize = 18;

	// 控件的宽度
	private int mWidth;
	// 控件的高度
	private int mHeight;
	// 单据内容区的宽度
	private int mBillWidth;
	// 单据内容区的高度
	private int mBillHeight;

	// 单据模板
	private BillTemplate mTemplate;

	// 滑动相关
	private Scroller mScroller;
	// 定义手势检测器实例
	private GestureDetectorCompat mDetector;
	// 阻力系数基数，值越大，阻力越大（如果单据出界，手指滑动距离与单据滑动距离比例系数基数，用于模拟滑动阻力）
	private float mScrollRadio = 5;

	// 背景图
	private BackgroudView mBackgroud;
	private Bitmap mBitmap;
	private Context mContext;

	// 所有空对应的编辑框
	private List<BlankEditText> mEtBlanks;
	// 所有印章对应的视图
	private List<SignView> mSignViews;
	// 所有闪电符对应的视图
	private List<FlashView> mFlashViews;

	public ZoomableBillView(Context context, AttributeSet attrs) {
		super(context, attrs);
		mContext = context;

		TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.ZoomableBillView, 0, 0);
		mTextSize = a.getFloat(R.styleable.ZoomableBillView_text_size, mTextSize);
		mScaleWeight = a.getFloat(R.styleable.ZoomableBillView_scale_weight, mScaleWeight);
		mScrollRadio = a.getFloat(R.styleable.ZoomableBillView_scroll_radio, mScrollRadio);
		Log.d(TAG, String.format("mTextSize:%s,mScaleWeight:%s", mTextSize, mScaleWeight));
		a.recycle();

		init();
	}

	/**
	 * 初始化
	 */
	private void init() {
		mScroller = new Scroller(mContext);
		mBackgroud = new BackgroudView(mContext);
		addView(mBackgroud);
		// 创建手势检测器
		mDetector = new GestureDetectorCompat(mContext, new BillScrollDetector());
		mEtBlanks = new ArrayList<BlankEditText>();
		mSignViews = new ArrayList<SignView>();
		mFlashViews = new ArrayList<FlashView>(1);
	}

	/**
	 * 设置单据模板
	 * 
	 * @param template
	 */
	public void setBillTempate(BillTemplate template) {
		mTemplate = template;
		// 初始化底图
		mBitmap = mTemplate.getBitmap();
		if (mBitmap == null) {
			Log.e(TAG, "底图为空，无法继续");
			return;
		}
		mBillWidth = mBitmap.getWidth();
		mBillHeight = mBitmap.getHeight();
		mBackgroud.setBitmap(mBitmap);
		Log.i(TAG, String.format("init mBillWidth:%s,mBillHeight:%s", mBillWidth, mBillHeight));
	}

	/**
	 * 初始化缩放比例，加入所有空等操作
	 */
	private void initContent() {
		mScale = mInitScale = (float) mWidth / mBillWidth;
		refreshZoomState();
		if (mListener != null) {
			mListener.onZoomInit(mZoomInEnable, mZoomOutEnable);
		}
		// 初始化背景图
		mBackgroud.postScale(mScale, mCurrentScaleTimes);
		// 初始化所有空
		List<BaseElementData> elements = mTemplate.getElementDatas();
		if (elements != null) {
			for (BaseElementData element : elements) {
				if (element instanceof BlankData) {
					BlankEditText etBlank = new BlankEditText(mContext);
					etBlank.apply((BlankData) element, mTextSize, mScale, mScaleWeight);
					addView(etBlank);
					mEtBlanks.add(etBlank);
				} else if (element instanceof SignData) {
					SignView signView = new SignView(mContext);
					if (signView.apply((SignData) element, mScale)) {
						addView(signView);
						signView.setOnLongClickListener(this);
						mSignViews.add(signView);
					} else {
						Log.e(TAG, "印章图片为空，将被忽略:" + element);
					}
				} else if (element instanceof FlashData) {
					FlashView flashView = new FlashView(mContext);
					flashView.apply((FlashData) element, mScale);
					addView(flashView);
					mFlashViews.add(flashView);
				}
			}
		}
	}

	/**
	 * 设置单据缩放监听
	 * 
	 * @param listener
	 */
	public void setBillZoomListener(BillZoomListener listener) {
		mListener = listener;
	}

	/**
	 * 放大
	 */
	public void zoomIn() {
		if (!mZoomInEnable) {
			Log.d(TAG, "can't zoomIn");
			return;
		}
		mZoomFlag = true;
		mCurrentScaleTimes++;
		mScale *= mScaleWeight;
		zoom();
	}

	/**
	 * 缩小
	 */
	public void zoomOut() {
		if (!mZoomOutEnable) {
			Log.d(TAG, "can't zoomOut");
			return;
		}
		mZoomFlag = false;
		mCurrentScaleTimes--;
		mScale /= mScaleWeight;
		zoom();
	}

	/**
	 * 缩放到初始缩放状态
	 */
	private void zoomToInit() {
		if (!mZoomOutEnable) {
			Log.d(TAG, "can't zoomOut");
			return;
		}
		mZoomFlag = false;
		mCurrentScaleTimes = 0;
		mScale = mInitScale;
		zoom();
	}

	/**
	 * 缩放具体实现方法
	 */
	private void zoom() {
		if (mListener != null) {
			if (mZoomFlag) {
				mListener.onZoomInStart(mCurrentScaleTimes);
			} else {
				mListener.onZoomOutStart(mCurrentScaleTimes);
			}

		}

		refreshZoomState();
		// 底图缩放
		mBackgroud.postScale(mScale, mCurrentScaleTimes);
		// 空缩放
		for (BlankEditText etBlank : mEtBlanks) {
			etBlank.postScale(mScale, mCurrentScaleTimes);
		}
		// 印章缩放
		for (SignView signView : mSignViews) {
			signView.postScale(mScale, mCurrentScaleTimes);
		}
		// 闪电符缩放
		for(FlashView flashView : mFlashViews) {
			flashView.postScale(mScale, mCurrentScaleTimes);
		}

		requestLayout();
		checkBorder(false);
		if (mListener != null) {
			if (mZoomFlag) {
				mListener.onZoomInEnd(mCurrentScaleTimes, mZoomInEnable, mZoomOutEnable);
			} else {
				mListener.onZoomOutEnd(mCurrentScaleTimes, mZoomInEnable, mZoomOutEnable);
			}
		}
		Log.i(TAG, String.format("zoom mScale:%s", mScale));
	}

	/**
	 * 刷新缩放状态
	 */
	private void refreshZoomState() {
		mZoomInEnable = mCurrentScaleTimes >= MAX_SCALE_TIMES ? false : true;
		mZoomOutEnable = mCurrentScaleTimes < 1 ? false : true;
		Log.i(TAG, "currentScaleTimes:" + mCurrentScaleTimes + ",zoomInEnable:" + mZoomInEnable + ",zoomOutEnable:" + mZoomOutEnable);
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		mWidth = MeasureSpec.getSize(widthMeasureSpec);
		mHeight = Math.round(Math.min(MeasureSpec.getSize(heightMeasureSpec), mBillHeight * mInitScale));
		if (mInitScale == -1) {// 初始化初始缩放比例
			initContent();
		}

		// 计算子控件的尺寸
		final int childCount = getChildCount();
		for (int i = 0; i < childCount; i++) {
			View child = getChildAt(i);
			ElementLayoutParams params = (ElementLayoutParams) child.getLayoutParams();
			if (params.getType() == ElementType.TYPE_BG) {
				// 如果是背景图片，宽根据父控件的宽定，高取缩放后背景图片高以及父控件高的最小值
				int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec((int) (mBillWidth * mScale), MeasureSpec.AT_MOST);
				int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec((int) (mBillHeight * mScale), MeasureSpec.AT_MOST);
				child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
			} else {
				if (child.getVisibility() != GONE) {
					child.measure(params.getWidth(), params.getHeight());
				}
			}
		}

		setMeasuredDimension(mWidth, mHeight);
		Log.d(TAG, String.format("onMeasure mWidth:%s,mHeight:%s", mWidth, mHeight));
	}

	@Override
	protected void onLayout(boolean changed, int l, int t, int r, int b) {
		final int childCount = getChildCount();
		for (int i = 0; i < childCount; i++) {
			View child = getChildAt(i);
			if (child.getVisibility() != GONE) {
				ElementLayoutParams params = (ElementLayoutParams) child.getLayoutParams();
				int left = params.getX();
				int top = params.getY();
				int right = params.getX() + params.getWidth();
				int bottom = params.getY() + params.getHeight();

				child.layout(left, top, right, bottom);
				Log.i(TAG, String.format("onLayout index:%s, left:%s,top:%s,right:%s,bottom:%s", i, left, top, right, bottom));
			}
		}
	}

	@SuppressLint("ClickableViewAccessibility")
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		mDetector.onTouchEvent(event);
		switch (event.getAction()) {
		case MotionEvent.ACTION_DOWN:
			Log.d(TAG, "down");
			return true;

		case MotionEvent.ACTION_MOVE:
			Log.d(TAG, "move");
			return true;

		case MotionEvent.ACTION_UP:
			checkBorder(true);
			return true;
		}

		return true;
	}

	@Override
	public void computeScroll() {
		if (mScroller.computeScrollOffset()) {
			scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
			// Log.i(TAG, "computeScroll " + mScroller.getCurrX() + " " +
			// mScroller.getCurrY());
			invalidate();
		}
	}

	/**
	 * 检测单据内容是否出界
	 * 
	 * @param animate
	 *            是否以动画方式调整位置
	 */
	private void checkBorder(boolean animate) {
		int[] border = getBorder();
		// 单据的边界
		int left = border[0];
		int top = border[1];
		int right = border[2];
		int bottom = border[3];
		// x，y方向上出界的距离
		int dx = 0;
		int dy = 0;

		if (top < 0) {
			dy = -top;
		} else if (bottom <= 0) {
			dy = bottom;
		}
		if (left < 0) {
			dx = -left;
		} else if (right <= 0) {
			dx = right;
		}
		if (dx != 0 || dy != 0) {
			if (animate) {
				mScroller.startScroll(getScrollX(), getScrollY(), dx, dy, 300);
				invalidate();
			} else {
				scrollBy(dx, dy);
			}

			// Log.d(TAG, "checkBorder dx:" + dx + ",dy:" + dy + ",scrollX:" +
			// getScrollX() + ",scrollY:" + getScrollY());
		}

	}

	/**
	 * 获取单据边界值
	 * 
	 * @return 返回4位长度的int数组[left, top, right, bottom]，分别表示各个方向离边界值的距离，小于0代表超出边界
	 */
	private int[] getBorder() {
		// 单据的边界
		int left = getScrollX();
		int top = getScrollY();
		int right = Math.round(mBillWidth * mScale - mWidth - left);
		int bottom = Math.round(mBillHeight * mScale - mHeight - top);
		// Log.d(TAG,
		// String.format("getBorder left:%s,top:%s,right:%s,bottom:%s", left,
		// top, right, bottom));

		int[] border = new int[] { left, top, right, bottom };
		return border;
	}

	@Override
	public boolean onInterceptTouchEvent(MotionEvent ev) {
		return true;
	}

	/**
	 * 单据手势监听
	 * 
	 * @author lucher
	 * 
	 */
	class BillScrollDetector extends SimpleOnGestureListener {
		@Override
		public boolean onScroll(MotionEvent e1, MotionEvent e2, float dx, float dy) {
			int[] border = getBorder();
			int left = border[0];
			int top = border[1];
			int right = border[2];
			int bottom = border[3];

			// 出界时加入滑动阻力
			if ((left <= 0 && dx < 0) || (right <= 0 && dx > 0)) {// left出界时，往右滑动或者right出界时，往左滑动
				// 根据滑动距离动态计算阻力
				float xScrollRadio = mScrollRadio + (float) e2.getX() / mWidth * mScrollRadio;
				dx = dx / xScrollRadio;
			}
			if ((top <= 0 && dy < 0) || (bottom <= 0 && dy > 0)) {// top出界时，往下滑动或者bottom出界时，往上滑动
				// 根据滑动距离动态计算阻力
				float yScrollRadio = mScrollRadio + (float) e2.getY() / mHeight * mScrollRadio;
				dy = dy / yScrollRadio;
			}

			scrollBy((int) dx, (int) dy);

			return true;
		}

		@Override
		public void onLongPress(MotionEvent e) {
			Toast.makeText(mContext, "long", 1000).show();
			super.onLongPress(e);
		}

		@Override
		public boolean onDoubleTap(MotionEvent e) {
			if (mZoomInEnable) {
				zoomIn();
			} else {
				zoomToInit();
			}
			return true;
		}
	}

	@Override
	public boolean onLongClick(View v) {
		// Toast.makeText(mContext, "long", 1000).show();
		return true;
	}
}
